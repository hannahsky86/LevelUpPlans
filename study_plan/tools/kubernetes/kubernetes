1. What is Kubernetes?
Answer: Kubernetes is an open-source container orchestration platform that automates deployment, scaling, and management of containerized applications.

Follow-up 1: What are the main components of Kubernetes?
Answer: Kubernetes has components like the API server, etcd (key-value store), controller manager, scheduler, kubelet, and kube-proxy.
Follow-up 2: What are Pods in Kubernetes?
Answer: Pods are the smallest deployable units in Kubernetes, representing a single instance of a running process in a cluster.
2. How does Kubernetes ensure high availability?
Answer: Kubernetes ensures high availability by distributing workloads across multiple nodes and using features like ReplicaSets and self-healing capabilities.

Follow-up 1: What role does the etcd component play in high availability?
Answer: etcd acts as the consistent and highly available key-value store for all cluster data.
Follow-up 2: What is a ReplicaSet in Kubernetes?
Answer: A ReplicaSet ensures that a specified number of pod replicas are running at all times.
3. What is the difference between Deployments and StatefulSets?
Answer: Deployments are used for stateless applications, while StatefulSets are designed for stateful applications and provide unique, persistent identifiers for pods.

Follow-up 1: Can Deployments be used for databases? Why or why not?
Answer: No, because Deployments do not guarantee stable network identities or persistent storage needed for databases.
Follow-up 2: What is a Headless Service, and how is it used with StatefulSets?
Answer: A Headless Service does not have a cluster IP and allows direct access to pods for StatefulSets.
4. Explain Kubernetes namespaces.
Answer: Namespaces are virtual clusters within a Kubernetes cluster that segregate resources for better organization and multi-tenancy.

Follow-up 1: How do you create a namespace in Kubernetes?
Answer: Use the command kubectl create namespace <namespace-name>.
Follow-up 2: How can you restrict resource usage in a namespace?
Answer: By using ResourceQuotas and LimitRanges.
5. What is a Service in Kubernetes?
Answer: A Service in Kubernetes provides a stable network endpoint to expose Pods to other services or external users.

Follow-up 1: What are the types of Kubernetes Services?
Answer: ClusterIP, NodePort, LoadBalancer, and ExternalName.
Follow-up 2: How does a ClusterIP Service work?
Answer: It assigns a virtual IP to the service, making it accessible only within the cluster.
6. How does Kubernetes perform scaling?
Answer: Kubernetes uses Horizontal Pod Autoscalers (HPA) to scale pods and Vertical Pod Autoscalers (VPA) to adjust resource requests and limits.

Follow-up 1: How does HPA determine when to scale?
Answer: HPA uses metrics like CPU, memory usage, or custom metrics to determine scaling.
Follow-up 2: What is a Cluster Autoscaler?
Answer: A Cluster Autoscaler adjusts the size of the cluster by adding or removing nodes.
7. What are ConfigMaps and Secrets in Kubernetes?
Answer: ConfigMaps store configuration data in key-value pairs, while Secrets store sensitive information like passwords and tokens.

Follow-up 1: How are Secrets encoded in Kubernetes?
Answer: Secrets are base64 encoded.
Follow-up 2: How can you inject ConfigMaps into a Pod?
Answer: By mounting them as volumes or using environment variables.
8. What is the purpose of a DaemonSet?
Answer: A DaemonSet ensures that a copy of a specific pod runs on all or selected nodes.

Follow-up 1: When would you use a DaemonSet?
Answer: For logging, monitoring, or networking agents on every node.
Follow-up 2: How do you delete a DaemonSet without deleting its pods?
Answer: Use kubectl delete daemonset <name> --cascade=orphan.
9. Explain Ingress in Kubernetes.
Answer: Ingress is an API object that manages external HTTP/S access to services within a cluster.

Follow-up 1: What are Ingress Controllers?
Answer: They are implementations that manage ingress resources, such as NGINX or Traefik.
Follow-up 2: What is the difference between NodePort and Ingress?
Answer: NodePort exposes services on a static port on each node, while Ingress routes external traffic via rules and supports TLS termination.
10. What is the difference between kubectl apply and kubectl create?
Answer: kubectl apply is used for declarative configuration and updates resources, while kubectl create is imperative and creates new resources.

Follow-up 1: Can you update a resource using kubectl create?
Answer: No, it will throw an error if the resource already exists.
Follow-up 2: What does kubectl edit do?
Answer: It allows you to modify resources directly in a text editor.
11. What are Kubernetes Labels and Annotations?
Answer: Labels are key-value pairs for identifying and organizing resources. Annotations store metadata that is not used for identifying resources.

Follow-up 1: How do selectors use labels?
Answer: Selectors match pods or other resources based on their labels.
Follow-up 2: How can you update a label on a running pod?
Answer: Use kubectl label pod <pod-name> <key>=<value>.
12. What is a PersistentVolume (PV) in Kubernetes?
Answer: PV is a storage resource in Kubernetes that abstracts details of storage from providers.

Follow-up 1: What is the difference between PV and PVC?
Answer: PV is a cluster resource, while PVC is a request for storage by a user.
Follow-up 2: How do you bind a PVC to a PV?
Answer: PVC and PV must have matching storage class, capacity, and access modes.
13. What is the role of kube-proxy in Kubernetes?
Answer: kube-proxy manages network routing and load balancing for services in the cluster.

Follow-up 1: What are the modes in which kube-proxy operates?
Answer: Userspace, iptables, and IPVS.
Follow-up 2: What happens if kube-proxy fails?
Answer: Service routing and load balancing within the cluster may break.
14. How does Kubernetes handle pod communication?
Answer: Pods communicate using the cluster network, where every pod gets a unique IP address.

Follow-up 1: What is the role of a CNI plugin in Kubernetes?
Answer: It configures network interfaces for pods.
Follow-up 2: What are common CNI plugins?
Answer: Flannel, Calico, Weave Net, and Cilium.

15. What is the purpose of a Kubernetes Scheduler?
Answer: The Scheduler assigns pods to nodes based on resource requirements and policies.

Follow-up 1: What factors does the Scheduler consider when assigning pods?
Answer: Resource requests, node taints, tolerations, affinities, and anti-affinities.
Follow-up 2: What happens if a pod cannot be scheduled?
Answer: The pod remains in a Pending state until suitable resources become available.
16. What are Taints and Tolerations in Kubernetes?
Answer: Taints allow nodes to repel certain pods, and tolerations let pods tolerate those taints.

Follow-up 1: How do you apply a taint to a node?
Answer: Use kubectl taint nodes <node-name> <key>=<value>:<effect>.
Follow-up 2: What are the effects of taints?
Answer: NoSchedule, PreferNoSchedule, and NoExecute.
17. What is the purpose of nodeSelector in Kubernetes?
Answer: nodeSelector is used to schedule pods onto specific nodes based on labels.

Follow-up 1: How is nodeSelector configured in a pod spec?
Answer: Add nodeSelector: <key>: <value> to the pod spec.
Follow-up 2: What is the difference between nodeSelector and node affinity?
Answer: nodeSelector is a simple key-value match, while node affinity offers more advanced matching rules.
18. What is Kubernetes RBAC?
Answer: Role-Based Access Control (RBAC) manages permissions within the Kubernetes cluster.

Follow-up 1: What are the main RBAC objects in Kubernetes?
Answer: Roles, ClusterRoles, RoleBindings, and ClusterRoleBindings.
Follow-up 2: How do you list roles in a namespace?
Answer: Use kubectl get roles -n <namespace>.
19. What is the purpose of a Kubernetes Job?
Answer: Jobs are used to manage and run batch tasks to completion.

Follow-up 1: What is the difference between a Job and a CronJob?
Answer: A Job runs once or a specified number of times, while a CronJob runs on a schedule.
Follow-up 2: How can you ensure a Job runs successfully?
Answer: By specifying completions and parallelism in the Job spec.
20. What are Kubernetes Custom Resource Definitions (CRDs)?
Answer: CRDs allow users to define their own API objects in Kubernetes.

Follow-up 1: How do you create a CRD?
Answer: Write a YAML manifest and apply it using kubectl apply.
Follow-up 2: What is the difference between CRDs and Operators?
Answer: CRDs define custom resources, while Operators automate lifecycle management for those resources.
21. What is a Horizontal Pod Autoscaler (HPA)?
Answer: HPA automatically adjusts the number of pods based on CPU/memory usage or custom metrics.

Follow-up 1: What command do you use to create an HPA?
Answer: kubectl autoscale deployment <deployment-name> --cpu-percent=<value> --min=<min-pods> --max=<max-pods>.
Follow-up 2: What metrics can HPA use?
Answer: CPU, memory, and custom metrics using the Metrics Server or Prometheus.
22. What are StatefulSets used for?
Answer: StatefulSets manage stateful applications and ensure stable identities and storage for pods.

Follow-up 1: How does a StatefulSet differ from a Deployment?
Answer: StatefulSets maintain a fixed ordering and unique pod identities.
Follow-up 2: What happens if a pod in a StatefulSet fails?
Answer: It is recreated with the same name and persistent volume claim.
23. What is a Kubernetes ConfigMap?
Answer: ConfigMaps store non-sensitive configuration data, like environment variables, for pods.

Follow-up 1: How do you create a ConfigMap from a file?
Answer: Use kubectl create configmap <name> --from-file=<file>.
Follow-up 2: Can ConfigMaps be updated without restarting pods?
Answer: Yes, if the ConfigMap is mounted as a volume with the subPath option.
24. How does Kubernetes manage rolling updates?
Answer: Rolling updates are handled by the Deployment controller, which gradually replaces old pods with new ones.

Follow-up 1: What command starts a rolling update?
Answer: Update the deployment spec with kubectl apply.
Follow-up 2: How can you pause a rolling update?
Answer: Use kubectl rollout pause deployment <deployment-name>.
25. What is a Kubernetes Volume?
Answer: A Volume is a directory accessible to containers in a pod, backed by storage types like emptyDir, hostPath, or cloud providers.

Follow-up 1: What is the difference between emptyDir and hostPath?
Answer: emptyDir is ephemeral, while hostPath mounts a directory from the host node.
Follow-up 2: How do PersistentVolumes (PV) differ from standard volumes?
Answer: PVs have a lifecycle independent of the pod and are used with PersistentVolumeClaims (PVCs).
26. What are Kubernetes probes?
Answer: Probes are mechanisms to check the health of pods. They include liveness, readiness, and startup probes.

Follow-up 1: What happens if a liveness probe fails?
Answer: The container is restarted.
Follow-up 2: How do you configure a readiness probe?
Answer: By specifying httpGet, exec, or tcpSocket checks in the pod spec.
27. What is Helm in Kubernetes?
Answer: Helm is a package manager for Kubernetes that simplifies the deployment and management of applications using charts.

Follow-up 1: What are Helm charts?
Answer: Predefined templates for Kubernetes applications.
Follow-up 2: How do you install a Helm chart?
Answer: Use helm install <release-name> <chart-name>.
28. What is the Kubernetes Metrics Server?
Answer: The Metrics Server collects resource usage data like CPU and memory for pods and nodes.

Follow-up 1: How do you install the Metrics Server?
Answer: Deploy the Metrics Server YAML manifest from the official Kubernetes GitHub repository.
Follow-up 2: What command shows pod resource usage?
Answer: kubectl top pods.
29. How does Kubernetes handle secrets securely?
Answer: Secrets are base64-encoded and can be encrypted at rest if encryption is enabled on the cluster.

Follow-up 1: How can you mount a secret in a pod?
Answer: By specifying it as a volume or using environment variables.
Follow-up 2: How can you ensure secrets are encrypted at rest?
Answer: Enable secret encryption in the Kubernetes API server using a custom encryption configuration.
30. What is the Kubernetes API Server?
Answer: The API Server is the central component that exposes the Kubernetes API to interact with the cluster.

Follow-up 1: How can you interact with the API Server?
Answer: Using kubectl, client libraries, or HTTP REST calls.
Follow-up 2: What is the role of authentication in the API Server?
Answer: It ensures that only authorized users or applications can access the cluster.

31. What is a Kubernetes Admission Controller?
Answer: Admission controllers are plugins in the Kubernetes API server that intercept requests to the cluster and enforce policies or modify the requests.

Follow-up 1: What are examples of Admission Controllers?
Answer: PodSecurityPolicy, ResourceQuota, and ValidatingWebhook.
Follow-up 2: How can you enable or disable an Admission Controller?
Answer: Modify the --enable-admission-plugins flag in the API server configuration.
32. What is the difference between PersistentVolume (PV) and StorageClass?
Answer: PV is a specific storage resource, while StorageClass defines a set of storage provisioner parameters for dynamic PV creation.

Follow-up 1: How do you specify a StorageClass in a PersistentVolumeClaim?
Answer: By setting the storageClassName field in the PVC spec.
Follow-up 2: What happens if a PVC doesn't specify a StorageClass?
Answer: Kubernetes uses the default StorageClass if one is defined.
33. What are Kubernetes Affinity and Anti-Affinity?
Answer: Affinity rules schedule pods to specific nodes based on preferred or required rules, while anti-affinity prevents pods from running together on the same node.

Follow-up 1: What is the difference between requiredDuringSchedulingIgnoredDuringExecution and preferredDuringSchedulingIgnoredDuringExecution?
Answer: The former is a hard requirement, while the latter is a soft preference.
Follow-up 2: How do you define a pod anti-affinity rule?
Answer: Use the spec.affinity.podAntiAffinity field in the pod spec.
34. How does Kubernetes handle container restarts?
Answer: Kubernetes uses the pod's restartPolicy (Always, OnFailure, or Never) to decide when to restart containers.

Follow-up 1: What is the default restart policy for Kubernetes pods?
Answer: Always.
Follow-up 2: What happens when a pod in a Deployment fails?
Answer: The ReplicaSet recreates the failed pod to maintain the desired replica count.
35. What is Kubernetes Cluster Autoscaler?
Answer: Cluster Autoscaler adjusts the number of nodes in a cluster based on pending pod resource requests.

Follow-up 1: How does Cluster Autoscaler decide when to scale down?
Answer: It scales down when nodes are underutilized and their pods can be moved to other nodes.
Follow-up 2: What are the prerequisites for using Cluster Autoscaler?
Answer: The cluster must use a supported cloud provider and have proper IAM permissions.
36. What is the Kubernetes control plane?
Answer: The control plane manages the Kubernetes cluster and consists of components like the API server, etcd, controller manager, and scheduler.

Follow-up 1: Where is etcd stored, and why is it critical?
Answer: etcd is stored on the control plane nodes and is critical for cluster state and configuration.
Follow-up 2: What happens if the control plane components fail?
Answer: The cluster may become unresponsive, but existing workloads continue running.
37. How does Kubernetes manage DNS for services?
Answer: Kubernetes uses CoreDNS to provide DNS resolution for services and pods within the cluster.

Follow-up 1: How do you access a service using DNS?
Answer: Use the format <service-name>.<namespace>.svc.cluster.local.
Follow-up 2: How can you troubleshoot DNS issues in Kubernetes?
Answer: Use tools like kubectl exec to run nslookup or dig commands inside a pod.
38. What is the role of kubelet in Kubernetes?
Answer: Kubelet is an agent that runs on each node and ensures containers are running as described in the pod specs.

Follow-up 1: How does kubelet communicate with the control plane?
Answer: Kubelet communicates with the API server over HTTPS.
Follow-up 2: What happens if kubelet on a node fails?
Answer: The node becomes NotReady, and pods may be rescheduled on other nodes.
39. What is a Kubernetes Volume Mount?
Answer: A volume mount is a directory within a container backed by a Kubernetes volume.

Follow-up 1: How do you specify a volume mount in a pod spec?
Answer: Define the volumeMounts field in the container spec.
Follow-up 2: Can a single volume be mounted to multiple containers?
Answer: Yes, volumes can be shared across containers in the same pod.
40. What is the difference between NodePort and LoadBalancer Services?
Answer: NodePort exposes the service on a static port across all nodes, while LoadBalancer integrates with cloud provider load balancers for external traffic.

Follow-up 1: Can a NodePort Service be accessed externally?
Answer: Yes, by using the node's external IP and the NodePort.
Follow-up 2: What are the limitations of NodePort?
Answer: It requires manual port management and lacks advanced load-balancing features.
41. How does Kubernetes handle ConfigMaps with multiple keys?
Answer: ConfigMaps can have multiple key-value pairs or be created from multiple files.

Follow-up 1: How do you access specific keys in a ConfigMap from a pod?
Answer: Use the subPath field when mounting the ConfigMap as a volume.
Follow-up 2: How do you create a ConfigMap with multiple files?
Answer: Use kubectl create configmap <name> --from-file=<file1> --from-file=<file2>.
42. What is the Kubernetes dashboard?
Answer: The Kubernetes dashboard is a web-based user interface for managing cluster resources.

Follow-up 1: How do you install the Kubernetes dashboard?
Answer: Deploy the official Kubernetes dashboard YAML manifest.
Follow-up 2: How do you secure the Kubernetes dashboard?
Answer: Use RBAC for access control and enable HTTPS with a secure token.
43. How does Kubernetes handle storage provisioning?
Answer: Kubernetes uses StorageClasses for dynamic provisioning and PersistentVolumes for static provisioning.

Follow-up 1: What is a reclaim policy in PersistentVolumes?
Answer: It determines what happens to the PV after the PVC is deleted (Retain, Delete, or Recycle).
Follow-up 2: How do you specify a default StorageClass?
Answer: Annotate it with storageclass.kubernetes.io/is-default-class: "true".
44. What is the purpose of Kubernetes Secrets?
Answer: Secrets store sensitive data such as passwords, tokens, and certificates.

Follow-up 1: How do you create a Secret from a file?
Answer: Use kubectl create secret generic <name> --from-file=<file>.
Follow-up 2: How do you reference a Secret in a pod?
Answer: Use the envFrom or volumes fields in the pod spec.
45. What is the difference between Deployment and ReplicaSet?
Answer: A Deployment manages ReplicaSets and provides declarative updates, while a ReplicaSet ensures the desired number of pod replicas.

Follow-up 1: Can you create a ReplicaSet directly?
Answer: Yes, but it is uncommon because Deployments provide more features.
Follow-up 2: How do you scale a ReplicaSet?
Answer: Use kubectl scale rs <name> --replicas=<number>.

46. What is a Kubernetes Pod?
Answer: A pod is the smallest deployable unit in Kubernetes, representing one or more containers that share the same network and storage.

Follow-up 1: What happens when a pod dies?
Answer: The pod itself is not restarted, but if managed by a controller (e.g., Deployment), a new pod is created to replace it.
Follow-up 2: How do you debug a pod in Kubernetes?
Answer: Use commands like kubectl logs <pod-name> or kubectl exec -it <pod-name> -- /bin/bash.
47. What is the difference between a Pod and a Container in Kubernetes?
Answer: A container is an isolated runtime environment, while a pod is a wrapper around one or more containers with shared resources like storage and networking.

Follow-up 1: Why does Kubernetes group containers into pods?
Answer: To allow closely related containers to share resources and coordinate as a single unit.
Follow-up 2: How do containers within a pod communicate?
Answer: They communicate via localhost on the pod's shared network namespace.
48. What is Kubernetes Resource Quota?
Answer: Resource Quotas limit the amount of CPU, memory, or object counts (like pods) a namespace can use.

Follow-up 1: How do you create a ResourceQuota?
Answer: Define a ResourceQuota YAML file and apply it with kubectl apply -f <file>.yaml.
Follow-up 2: What happens if a pod request exceeds the ResourceQuota?
Answer: The pod will not be scheduled, and the user will receive an error.
49. How does Kubernetes manage logs?
Answer: Kubernetes manages logs at the container level and stores them in the /var/log directory or streams them via logging drivers.

Follow-up 1: How can you view logs of a pod?
Answer: Use kubectl logs <pod-name>.
Follow-up 2: How do you implement centralized logging in Kubernetes?
Answer: Use tools like Fluentd, ELK stack, or Promtail with Loki.
50. What are Kubernetes Operators?
Answer: Operators are application-specific controllers that extend Kubernetes' functionality to automate complex application tasks.

Follow-up 1: How are Operators implemented?
Answer: Using Custom Resource Definitions (CRDs) and custom controllers.
Follow-up 2: What are examples of Kubernetes Operators?
Answer: Prometheus Operator, Kafka Operator, and MongoDB Operator.
51. What is the difference between kubectl delete and kubectl delete --cascade=orphan?
Answer: kubectl delete deletes resources along with their dependents, while kubectl delete --cascade=orphan deletes only the resource but leaves its dependents.

Follow-up 1: What are dependent resources in Kubernetes?
Answer: Resources like pods, ReplicaSets, and PersistentVolumeClaims that are linked to a parent resource.
Follow-up 2: What happens to pods when their Deployment is deleted without --cascade=orphan?
Answer: The pods are also deleted.
52. What is Kubernetes Federation?
Answer: Federation is a feature that allows you to manage multiple Kubernetes clusters as a single entity.

Follow-up 1: What are the use cases for Federation?
Answer: Disaster recovery, global load balancing, and high availability.
Follow-up 2: How do you enable Federation?
Answer: Use the Kubernetes Federation v2 project or other external tools like Kubefed.
53. What is Kubernetes Network Policy?
Answer: A Network Policy defines how pods communicate with each other and with external endpoints.

Follow-up 1: How do you create a Network Policy?
Answer: Use a YAML manifest and apply it with kubectl apply -f <file>.yaml.
Follow-up 2: What happens if no Network Policies are defined in a namespace?
Answer: All traffic is allowed by default.
54. How does Kubernetes manage container images?
Answer: Kubernetes pulls container images from container registries like Docker Hub, Azure Container Registry (ACR), or Amazon ECR.

Follow-up 1: How do you specify a private registry in Kubernetes?
Answer: Use an imagePullSecret in the pod spec.
Follow-up 2: How can you preload images on a node to reduce startup time?
Answer: Use docker pull or ctr commands on the node before scheduling pods.
55. What is Kubernetes Service Discovery?
Answer: Service Discovery is the process of locating and connecting to Kubernetes services using DNS or environment variables.

Follow-up 1: How do environment variables aid Service Discovery?
Answer: Kubernetes automatically injects service information into pods as environment variables.
Follow-up 2: What role does CoreDNS play in Service Discovery?
Answer: CoreDNS resolves service names to their ClusterIP or external addresses.
56. What is Kubernetes Pod Priority?
Answer: Pod Priority assigns importance levels to pods, determining which pods are evicted first during resource shortages.

Follow-up 1: What happens if two pods have the same priority?
Answer: Kubernetes evicts pods based on other factors like age or resource usage.
Follow-up 2: How do you create a PriorityClass?
Answer: Use a YAML manifest defining the PriorityClass and apply it with kubectl apply.
57. What is a Kubernetes Horizontal Pod Autoscaler (HPA)?
Answer: HPA adjusts the number of pod replicas in a deployment based on observed CPU, memory, or custom metrics.

Follow-up 1: How do you enable custom metrics for HPA?
Answer: Integrate a metrics server like Prometheus with the custom metrics API.
Follow-up 2: What is the default polling interval for HPA?
Answer: 30 seconds.
58. What is a Kubernetes Init Container?
Answer: Init containers run before the main containers in a pod and are used for initialization tasks.

Follow-up 1: How do you define an Init Container in a pod spec?
Answer: Use the initContainers field alongside containers in the pod YAML.
Follow-up 2: Can Init Containers share data with main containers?
Answer: Yes, via shared volumes.
59. What is Kubernetes Pod Disruption Budget (PDB)?
Answer: PDB ensures a minimum number or percentage of pods remain available during voluntary disruptions like node maintenance.

Follow-up 1: How do you define a PDB?
Answer: Use a YAML manifest specifying minAvailable or maxUnavailable pods.
Follow-up 2: What happens if a PDB is violated?
Answer: The disruption is blocked until the PDB requirements are met.
60. How does Kubernetes handle time-sensitive tasks?
Answer: Kubernetes uses CronJobs to schedule recurring tasks and Jobs for one-time tasks.

Follow-up 1: What happens if a CronJob misses its schedule?
Answer: It depends on the concurrencyPolicy and startingDeadlineSeconds settings.
Follow-up 2: How do you disable a CronJob temporarily?
Answer: Use kubectl patch to set the suspend field to true.

61. What is Kubernetes Multi-Container Pod?
Answer: A Multi-Container Pod includes more than one container in a single pod, sharing the same network namespace and storage volumes.

Follow-up 1: What are common use cases for Multi-Container Pods?
Answer: Log processing sidecars, data caching, and proxies.
Follow-up 2: How do containers in the same pod communicate?
Answer: Using localhost since they share the same network namespace.
62. What is a Kubernetes Headless Service?
Answer: A Headless Service does not assign a ClusterIP and is used for direct pod-to-pod communication or when DNS records are required for each pod.

Follow-up 1: How do you create a Headless Service?
Answer: Set ClusterIP: None in the Service spec.
Follow-up 2: What are the advantages of a Headless Service?
Answer: Direct access to individual pods and support for StatefulSets.
63. What are Kubernetes Volume Access Modes?
Answer: Access Modes define how a volume can be mounted, such as ReadWriteOnce (RWO), ReadOnlyMany (ROX), and ReadWriteMany (RWX).

Follow-up 1: Which access mode is commonly used for database workloads?
Answer: ReadWriteOnce (RWO).
Follow-up 2: How do you determine the access mode of a PersistentVolume?
Answer: By describing the PV using kubectl describe pv <pv-name>.
64. What is Kubernetes Rolling Update Strategy?
Answer: Rolling updates replace old pod instances with new ones incrementally, ensuring no downtime.

Follow-up 1: How do you configure the update strategy in a Deployment?
Answer: Set the spec.strategy.type to RollingUpdate and define maxSurge and maxUnavailable.
Follow-up 2: How do you monitor a rolling update?
Answer: Use kubectl rollout status deployment <deployment-name>.
65. What is a Kubernetes Custom Scheduler?
Answer: A Custom Scheduler allows users to define custom scheduling logic for pods instead of relying on the default Kubernetes scheduler.

Follow-up 1: How do you specify a Custom Scheduler for a pod?
Answer: Use the schedulerName field in the pod spec.
Follow-up 2: What scenarios require a Custom Scheduler?
Answer: Advanced placement requirements like GPU allocation or cost-optimization strategies.
66. What is Kubernetes CSI (Container Storage Interface)?
Answer: CSI is a standard API that allows storage vendors to integrate their solutions with Kubernetes.

Follow-up 1: What are the benefits of using CSI drivers?
Answer: Vendor independence, consistent API, and easier storage management.
Follow-up 2: How do you list installed CSI drivers in a cluster?
Answer: Use kubectl get csidrivers.
67. What is Kubernetes Pod Eviction?
Answer: Pod eviction occurs when a pod is forcefully removed due to node resource pressure or policy constraints.

Follow-up 1: What happens to evicted pods managed by a Deployment?
Answer: The Deployment recreates new pods to maintain the desired replica count.
Follow-up 2: How can you prevent critical pods from being evicted?
Answer: Use priorityClass with a high value or set tolerations for specific node taints.
68. What are Kubernetes Runtime Classes?
Answer: Runtime Classes allow you to define different container runtimes for pods, such as runc or Kata Containers.

Follow-up 1: How do you specify a Runtime Class in a pod spec?
Answer: Add runtimeClassName: <class-name> to the pod spec.
Follow-up 2: Why would you use multiple container runtimes in a cluster?
Answer: For enhanced security (e.g., Kata Containers) or performance optimization.
69. What is the purpose of Kubernetes Helm Hooks?
Answer: Helm hooks allow you to run tasks at specific points in the release lifecycle, such as pre-install or post-upgrade.

Follow-up 1: What are common use cases for Helm hooks?
Answer: Database migrations, configuration generation, or custom validations.
Follow-up 2: How do you define a Helm hook in a chart?
Answer: Use the helm.sh/hook annotation in the manifest file.
70. What is Kubernetes ClusterIP Service?
Answer: A ClusterIP Service exposes the application internally within the cluster using a stable virtual IP.

Follow-up 1: Can ClusterIP Services be accessed externally?
Answer: No, unless combined with an external service like NodePort or Ingress.
Follow-up 2: What command lists all ClusterIP Services in a namespace?
Answer: kubectl get svc -n <namespace>.
71. How does Kubernetes handle Pod Lifecycle Events?
Answer: Kubernetes handles pod lifecycle events like Pending, Running, Succeeded, and Failed based on container states.

Follow-up 1: What does the CrashLoopBackOff state indicate?
Answer: A pod repeatedly fails and restarts due to a container crash.
Follow-up 2: How do you debug a pod stuck in Pending?
Answer: Check resource availability and node affinity rules.
72. What is Kubernetes Drain Command?
Answer: The kubectl drain command safely evicts all pods from a node before performing maintenance.

Follow-up 1: What happens to pods managed by a Deployment when a node is drained?
Answer: They are rescheduled on other nodes.
Follow-up 2: How do you ensure critical pods remain unaffected during a drain?
Answer: Use PodDisruptionBudgets (PDBs).
73. What is Kubernetes Horizontal Pod Scaling?
Answer: Horizontal Pod Scaling adjusts the number of pod replicas in a Deployment or ReplicaSet.

Follow-up 1: What metrics are commonly used for Horizontal Pod Scaling?
Answer: CPU, memory, and custom application metrics.
Follow-up 2: How do you manually scale a Deployment?
Answer: Use kubectl scale deployment <name> --replicas=<count>.
74. What is the Kubernetes kubeconfig File?
Answer: The kubeconfig file contains configuration information to access and authenticate with Kubernetes clusters.

Follow-up 1: Where is the default kubeconfig file located?
Answer: ~/.kube/config.
Follow-up 2: How do you specify a custom kubeconfig file?
Answer: Use the --kubeconfig flag with kubectl commands.
75. What is Kubernetes PersistentVolume Reclaim Policy?
Answer: The reclaim policy determines what happens to a PersistentVolume when its claim is deleted (Retain, Delete, or Recycle).

Follow-up 1: What does the Retain reclaim policy do?
Answer: It retains the volume for manual reuse after the claim is deleted.
Follow-up 2: How can you change the reclaim policy of a PersistentVolume?
Answer: Edit the PV using kubectl edit pv <name>.
76. What is Kubernetes Event Object?
Answer: Events provide a record of state changes and important occurrences in a Kubernetes cluster.

Follow-up 1: How do you view events in a namespace?
Answer: Use kubectl get events -n <namespace>.
Follow-up 2: What are common reasons for Warning-level events?
Answer: Resource shortages, failed probes, or pod scheduling issues.
77. How does Kubernetes handle Pod Preemption?
Answer: Pods with higher priority can preempt lower-priority pods to free up resources.

Follow-up 1: How do you prevent critical pods from being preempted?
Answer: Assign them a high priorityClass value.
Follow-up 2: What happens to preempted pods?
Answer: They are evicted and enter a Failed state.
78. What is Kubernetes Pod Security Context?
Answer: Security context defines security settings for pods or containers, such as user ID, group ID, and capabilities.

Follow-up 1: How do you run a container as a non-root user?
Answer: Set runAsUser in the pod's security context.
Follow-up 2: What is the purpose of the fsGroup field?
Answer: It ensures shared storage volumes have the correct file system group ownership.

79. What is Kubernetes Pod Anti-Affinity?
Answer: Pod Anti-Affinity ensures that specific pods are not scheduled on the same node or within a certain topology (e.g., zone).

Follow-up 1: How do you configure Pod Anti-Affinity in a pod spec?
Answer: Use spec.affinity.podAntiAffinity with requiredDuringSchedulingIgnoredDuringExecution or preferredDuringSchedulingIgnoredDuringExecution.
Follow-up 2: What is a common use case for Pod Anti-Affinity?
Answer: Distributing replicas of a service across nodes for fault tolerance.
80. What is the Kubernetes API Aggregation Layer?
Answer: The API Aggregation Layer extends the Kubernetes API by adding custom APIs hosted outside the core Kubernetes API server.

Follow-up 1: What are the key components of the API Aggregation Layer?
Answer: The API server, aggregation layer proxy, and custom API servers.
Follow-up 2: What is an example use case for API Aggregation?
Answer: Adding monitoring APIs or third-party services to the cluster.
81. What are Kubernetes Service Accounts?
Answer: Service Accounts provide an identity for pods to interact with the Kubernetes API.

Follow-up 1: How do you create a Service Account?
Answer: Use kubectl create serviceaccount <name>.
Follow-up 2: How do you attach a Service Account to a pod?
Answer: Use the serviceAccountName field in the pod spec.
82. What is Kubernetes Resource Request and Limit?
Answer: Resource requests specify the minimum resources a pod needs, while limits specify the maximum resources it can use.

Follow-up 1: What happens if a pod exceeds its resource limit?
Answer: The container is throttled (CPU) or terminated (memory).
Follow-up 2: How do resource requests affect pod scheduling?
Answer: The scheduler places pods on nodes that meet their resource requests.
83. What is Kubernetes PreStop Hook?
Answer: A PreStop hook allows you to run a command or send an HTTP request before a container is terminated.

Follow-up 1: How do you define a PreStop hook in a pod spec?
Answer: Use lifecycle.preStop with exec or httpGet.
Follow-up 2: What are common use cases for PreStop hooks?
Answer: Cleaning up resources, closing connections, or graceful shutdowns.
84. What is Kubernetes ConfigMap Projection?
Answer: ConfigMap projection allows you to specify how ConfigMap data is presented in a volume.

Follow-up 1: How do you use a projection for a ConfigMap?
Answer: Use the volume.projection.configMap field in the pod spec.
Follow-up 2: What is a benefit of ConfigMap projection?
Answer: Fine-grained control over which keys are included in the volume.
85. What is Kubernetes Horizontal Pod Autoscaler Cooldown Period?
Answer: The cooldown period is the time HPA waits before scaling again after a recent scaling event.

Follow-up 1: How do you configure the cooldown period for HPA?
Answer: Set the stabilizationWindowSeconds field in the HPA spec.
Follow-up 2: Why is the cooldown period important?
Answer: To prevent frequent scaling actions due to temporary spikes.
86. What is Kubernetes Canary Deployment?
Answer: A Canary Deployment gradually rolls out changes to a small subset of users before deploying to the entire user base.

Follow-up 1: How can you implement Canary Deployments in Kubernetes?
Answer: Use multiple Deployments or a combination of Ingress and Services with weight-based routing.
Follow-up 2: What tools can help manage Canary Deployments?
Answer: Argo Rollouts, Flagger, or Istio.
87. What is Kubernetes InitContainer Restart Behavior?
Answer: Init containers restart until they complete successfully, after which the main containers are started.

Follow-up 1: What happens if an InitContainer fails?
Answer: The pod remains in the Init state until the InitContainer succeeds.
Follow-up 2: Can InitContainers run concurrently with the main containers?
Answer: No, they must complete before the main containers start.
88. What is Kubernetes ClusterRole?
Answer: ClusterRoles provide permissions at the cluster scope, such as for nodes, PersistentVolumes, or other non-namespaced resources.

Follow-up 1: How do you bind a ClusterRole to a user?
Answer: Use a ClusterRoleBinding.
Follow-up 2: What is the difference between Role and ClusterRole?
Answer: Roles are namespace-specific, while ClusterRoles apply cluster-wide.
89. What is Kubernetes Ingress Path Matching?
Answer: Ingress path matching allows routing traffic based on URL paths to specific services.

Follow-up 1: What are the path matching types supported by Ingress?
Answer: Exact, Prefix, and ImplementationSpecific.
Follow-up 2: How do you define a path-based rule in an Ingress?
Answer: Use the spec.rules.http.paths field in the Ingress YAML.
90. What is Kubernetes Topology Spread Constraint?
Answer: Topology Spread Constraints ensure that pods are evenly distributed across failure domains like zones or nodes.

Follow-up 1: How do you configure a Topology Spread Constraint?
Answer: Use the spec.topologySpreadConstraints field in the pod spec.
Follow-up 2: What happens if a topology spread constraint cannot be satisfied?
Answer: The pod remains unscheduled until the constraint is met.
91. What is Kubernetes Pod Readiness Gate?
Answer: Readiness Gates allow external conditions to determine whether a pod is ready.

Follow-up 1: How do you define a readiness gate?
Answer: Use spec.readinessGates with custom conditions in the pod spec.
Follow-up 2: What are common use cases for Readiness Gates?
Answer: Integrating external health checks or dependency checks.
92. What is Kubernetes Eviction Policy for DaemonSets?
Answer: DaemonSets are not evicted during node drains unless explicitly forced.

Follow-up 1: How do you evict DaemonSet pods manually?
Answer: Delete the pod, and the DaemonSet controller will recreate it.
Follow-up 2: Why are DaemonSets typically not evicted during drains?
Answer: To ensure essential services like logging or monitoring remain active.
93. What is Kubernetes Pod Termination Grace Period?
Answer: The grace period allows containers to shut down cleanly before being forcibly terminated.

Follow-up 1: How do you configure the termination grace period?
Answer: Use the terminationGracePeriodSeconds field in the pod spec.
Follow-up 2: What happens if the grace period expires?
Answer: The container is terminated with a SIGKILL signal.
94. What is Kubernetes Volume Snapshot?
Answer: Volume Snapshots allow you to create backups of PersistentVolumes at a specific point in time.

Follow-up 1: How do you create a Volume Snapshot?
Answer: Use a VolumeSnapshot resource with a VolumeSnapshotClass.
Follow-up 2: What is a common use case for Volume Snapshots?
Answer: Disaster recovery or point-in-time restores for databases.
95. What is Kubernetes Pod Security Admission?
Answer: Pod Security Admission is a built-in admission controller that enforces Pod Security Standards (Baseline, Restricted, Privileged).

Follow-up 1: How do you enable Pod Security Admission?
Answer: Configure the --enable-admission-plugins flag on the API server.
Follow-up 2: What is the difference between Baseline and Restricted security levels?
Answer: Baseline allows minimal privileges, while Restricted enforces strict security controls.
96. What is Kubernetes Ephemeral Containers?
Answer: Ephemeral Containers are temporary containers used for debugging running pods.

Follow-up 1: How do you add an Ephemeral Container to a running pod?
Answer: Use kubectl debug <pod-name> --image=<image-name>.
Follow-up 2: Do Ephemeral Containers have access to the pod’s data?
Answer: Yes, they share the pod's namespaces.
97. What is Kubernetes Probe Timeout?
Answer: Probe timeout specifies how long Kubernetes waits for a health check response before considering it failed.


97. What is Kubernetes Probe Timeout?
Answer: Probe timeout specifies how long Kubernetes waits for a health check response before considering it failed.

Follow-up 1: How do you configure the timeout for a probe?

Answer: Set the timeoutSeconds field in the probe configuration (livenessProbe, readinessProbe, or startupProbe).
Follow-up 2: What happens if a probe times out?

Answer: Kubernetes considers the probe failed and takes appropriate actions, such as restarting the container or marking the pod as not ready.
98. What is Kubernetes Node Affinity?
Answer: Node Affinity is a set of rules that determines how pods are scheduled onto nodes based on labels.

Follow-up 1: What is the difference between requiredDuringSchedulingIgnoredDuringExecution and preferredDuringSchedulingIgnoredDuringExecution in Node Affinity?

Answer: requiredDuringSchedulingIgnoredDuringExecution is a hard requirement, while preferredDuringSchedulingIgnoredDuringExecution is a soft preference.
Follow-up 2: How do you apply Node Affinity to a pod?

Answer: Use the spec.affinity.nodeAffinity field in the pod spec.
99. What is Kubernetes Pod Overhead?
Answer: Pod overhead accounts for the extra resources required to manage a pod in addition to its container resource requests.

Follow-up 1: How is pod overhead calculated?

Answer: Kubernetes adds the overhead defined in the pod's RuntimeClass to the pod's resource requests.
Follow-up 2: Why is pod overhead important?

Answer: It ensures that sufficient resources are allocated to the node for managing pods efficiently, preventing overcommitment.
100. What is Kubernetes PriorityClass?
Answer: PriorityClass is a resource that defines the importance of pods, influencing pod scheduling and eviction order.

Follow-up 1: How do you create a PriorityClass?

Answer: Use a YAML manifest with the kind: PriorityClass and apply it using kubectl apply -f <file>.yaml.
Follow-up 2: What happens if two pods have the same priority during scheduling?

Answer: Kubernetes uses other factors, like resource requests and node availability, to decide which pod gets scheduled first.
